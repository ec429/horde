-=====--------------------------------------------------------
:Horde: An HTTP server designed around message-passing daemons
-=====--------------------------------------------------------

This document is a cross between a specification, a manual, and a plan of future development; these three functions will be separated out as the project matures.

Release Notes: see NEWS
License details: see COPYING

How the server works:
---------------------
The actual 'horde' process is the dispatcher, with the following functions:
	Is the initial process, holds the listen()ing socket, has a pipe() to each child produced
	When a request comes in on socket, fork() a 'net' process
	When a request comes in over a pipe, hand it off to whatever process is registered to handle it (if none are running, fork() a new one)
	When a response comes in over a pipe, send it to the appropriate recipient.

Every child process (with the exception of 'net') is a 'handler', which is registered with the dispatcher by an entry in the .horde file.
The core handlers are:
	net		Calls accept() on the listening socket, does protocol with HTTP.  Calls 'ext' and 'log', and 'proc' to obtain the entity body
	proc	Loads a resource from disk, and applies appropriate preprocessing to it.  Calls appropriate preprocessor daemons
	ext		Determines the Content-Type (MIMEtype) of a document based on its extension.  Is a daemon (rather than a libhorde function) in order to amortise the cost of reading in /etc/mime.types
	log		Writes lines to the log file (/var/log/horde).  Exists to serialise these writes, obviating the need for locking
Other handlers go in the modules/ directory; any site-specific handlers go in modules/local/.

The standard way of extending horde's capabilities is by registering processors with 'proc'; this is done by an entry in a .proc file; typically the name should be {modulename}.proc.
One preprocessor is provided as an example of how the proc system works; it is called 'pico' and emulates the dynamic rewriting functions of the "httpico" webserver, an earlier (and somewhat unsuccessful) project by the same developer.  (The main reason for implementing 'pico' was that the author had used its features throughout his own website)

Good things to note: because all the preprocessor daemons communicate only through textual IPC (using a simple RPC protocol), they can be implemented in a wide variety of languages, although it helps if you have a binding for the hmsg-related libhorde functions.

Readiness:
----------
All workers that may conceivably need to issue sub-requests must use the (ready) message to signal that they are able to take a new request.
All workers of which only one instance may exist must always be ready to accept a new request; this usually means that they never issue sub-requests and use their stdin-buffer to queue requests.
A module uses the 'only' flag to indicate in which of the above categories it resides.  At present the dispatcher assumes these categories are mutually exclusive and exhaustive.

If you need to implement functionality involving both a gatekeeper to a shared resource and the use of subrequests (eg. to gather state), you should split it into two modules, so that the gatekeeper merely becomes one of the subrequests of the application logic / driver module.

proc Rules:
-----------
The preprocessor-matching rules in .proc are expression trees based very loosely on LISP forms (except using [square brackets] instead of (parens) because the latter are already used by the horde message protocol.  In a future version the roles of these two characters may be swapped).  For instance, the rule used by 'pico' is:
	[or [= [ext]["pico"]] [and [= [subst [0][5][ctype]]["text/"]] [grep [str [body]]["<?pico"]]]]
In a more conventional notation, this would be something like
	(ext=="pico") || ((ctype[0:5]=="text/") && (grep((str)body, "<?pico")))
There are three fundamental kinds of node here: operators, constants, and variables.  Operators include things like [=] and [or], which do the obvious things with their arguments, but also more elaborate functions like [grep] and [subst], the latter of which forms a substring from its third argument based on the first two.  Most of these operators are defined to do something useful if given too many arguments; for instance [= [a][b][c]] returns (a==b)&&(a==c), while [or [a][b][c]] returns a||b||c.  In fact it should be noted that operators short-circuit where natural, particularly [and] and [or].
The constants are things like ["text/"] (a string) and [0] and [5] (integers).  There is a third data type which cannot be supplied as a constant, and that is the "BLO" or "Binary Large Object", an array of bytes which carries its length with it (instead of using NUL-termination).
Variables are provided by the calling environment (in this case 'proc', but the expression interpreter is sufficiently general to be usable elsewhere) and include such things as [ext] (the file's extension) and [ctype] (the content-type determined by 'ext').  There is also [body], which is a BLO containing the body of the resource; because [grep] only operates on strings this is cast to string type with the [str] operator (a reasonable thing to do because files of type text/* rarely contain embedded NULs).  There are also casts for [num] and [blo]; casting to/from numeric (integer) type converts like printf-family %lu.

Pitfalls:
---------
libhorde's hmsg allows embedded NULs in data, thanks to hmsg->dlen by way of new_hmsg_d().  BUT... it doesn't allow them in htags, which should be purely textual.
On a related note, some preprocessors (namely, those operating only on textual data, and which will typically only be /called/ for textual data) can pretend all-the-world's-a-Cstring, and ignore the possibility of NULs - after all, who passes an image file to a preprocessor?  You may, however, feel that robustness is worth the slight extra complication involved in using hmsg->dlen.
Another way to pass binary data, rather than using new_hmsg_d(), is to use the (read) tag, and either a file on disk or a FIFO (named pipe); this will be abstracted away on the receiving side by libhorde.  Notice however that this facility means that hmsg_from_str() can block (because it's reading from a file which might be a pipe).

Plans:
------
TODO: replace the hex-encoding with escaping (it's much more textual)
TODO: make the libhorde interfaces use string structs (rather than having the new_hmsg and new_hmsg_d profusion)
TODO: cull excessive idle workers
TODO: add a second form of time profiling in dispatcher, which doesn't charge a worker for the time it spends waiting for someone else (start counting when you receive a message, stop counting when you send one)
TODO: make proc pay attention to the (onfail) attribute
TODO: make 'net' handle errors by requesting (proc /500.htm), though find a way to detect loops (in case a 500 page triggers an error/bug within proc or one of its processors)
TODO: HTTP pipelining in 'net' (controlled, of course, by hst.pipeline)
TODO: Handle hostnames in GET-url (check it's ours!)
TODO: Bernstein chaining - have a launcher that binds the socket, drops privs, then execs horde.  At the moment horde could (maybe) regain privs if compromised

Sample Transcript:
------------------
This section is not entirely accurate: the following transcript, while a reasonable way of doing things, does not correspond to the current implementation (for instance, path resolution in this case actually triggers a 302; proc doesn't use a sock_un but instead reads/writes the data through disp).  The name 'disp' is used to represent the dispatcher, whose actual executable name is 'horde'.  This transcript was originally produced not for documentation but as a rough specification of "how things should work" during the early stages of development.

Example Transcript; {} denotes hex-encoding.  Internally generated message data are hex-encoded iff they contain parens or spaces or begin with a '#' (wh. is used to indicate hex-encoding).  User-input data may be hex-encoded unnecessarily.  [] denotes variables.
	disp fork() exec(path)
	disp fork() exec(stats)
	C>disp connect
	disp fork() exec(net)
	net accept()
	C>net: GET / HTTP/1.0
	net>disp: (path /)
	disp>path: (path (from net) /)
	path>disp: (path (to net) /index.html)
	disp>net: (path /index.html)
	net>disp: (proc /index.html)
	disp fork() exec(proc)
	disp>proc: (proc (from net) /index.html)
	proc reads index.html; it contains some <?pico> tags and otherwise matches no rules
	proc opens a sock_un, /tmp/.horde_[pid] (hereonin 'sock')
	proc>disp: (pico /tmp/.horde_[pid])
	disp fork() exec(pico)
	disp>pico: (pico (from proc) /tmp/.horde_[pid])
	pico>sock>proc: (waiting pico)
	proc>sock>pico: (pico {[page html data]})
	pico>disp: (uptime)
	disp>pico: (uptime {horde: 8 days, 15:37:16 | system: 73 days, 01:49:58})
	pico>sock>proc: (pico {[page html data, pico-processed]})
	pico closes sock
	proc closes sock
	proc>disp (proc (to net) {[page html data, pico-processed]})
	disp>net (proc {[page html data, pico-processed]})
	net>C: the HTTP response, 200 OK and all the data
	net>disp (stats (time [time_t]) (ip [IP]) (status 200) (bytes [bytes]) (file /index.html) /*...etc...*/ append)
	disp>stats (stats (from net) /*...etc...*/ append)
	stats>disp (stats (to net) append)
	disp>net (stats append)
	/* we assume pipelining was not requested */
	net>disp (close)
	net return()s
	stdin>disp: (shutdown)
	disp>* (shutdown)
	path return()s
	proc return()s
	stats return()s
	pico return()s
	disp>stdout: (shutdown (when now))
	disp return()s
