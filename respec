All workers that may conceivably need to issue sub-requests must use the (ready) message to signal that they are able to take a new request.
All workers of which only one instance may exist must always be ready to accept a new request; this usually means that they never issue sub-requests and use their stdin-buffer to queue requests.
A module uses the 'only' flag to indicate in which of the above categories it resides.  At present the dispatcher assumes these categories are mutually exclusive and exhaustive.

If you need to implement functionality involving both a gatekeeper to a shared resource and the use of subrequests (eg. to gather state), you should split it into two modules, so that the gatekeeper merely becomes one of the subrequests of the application logic / driver module.

TODO: cull excessive idle workers.
TODO: make a generic version of the read loops, perhaps 'hmsg hmsg_expect(const char *funct);'
TODO: add a second form of time profiling in dispatcher, which doesn't charge a worker for the time it spends waiting for someone else (start counting when you receive a message, stop counting when you send one)
TODO: instead of putting all the horde and proc knowledge into single '.horde' and '.proc' files, search for '*.horde' and '*.proc' files and read them all.  Thus, pico will have a 'pico.horde' (add (name pico) (prog ./pico) (stdinit)) and a 'pico.proc' (add (rule [or [= [ext]["pico"]] [and [= [subst [0][5][ctype]]["text/"]] [grep [str [body]]["<?pico"]]]]) (proc pico) (onfail passthru)).
TODO: make proc pay attention to the (onfail) attribute
